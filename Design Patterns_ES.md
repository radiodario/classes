# Design Patterns

## Que es un Design Pattern?

Patterns (patrones) son soluciones a problemas que pueden ser reutilizadas f√°cilmente, como plantillas o recetas para problemas. Sin embargo, no son soluciones exactas. Nos dan sin embargo un plan de soluci√≥n.

Ventajas
* Evitan problemas comunes
* Proveen soluciones generalizadas
* Disminuyen el tama√±o total de nuestro c√≥digo
* A√±aden al vocabulario de un developer
* Los patterns evolucionan y mejoran


## Patr√≥n contra Anti-Patr√≥n
Patterns son "practicas estandard", Anti-Patterns son lecciones aprendidas.

* Describen una mala soluci√≥n a un problema la cual cre√≥ una mala situaci√≥n.
* Describen c√≥mo salir de la situaci√≥n y llegar a una buena soluci√≥n.

> Un mal dise√±o que merece la pena documentar

### Anti-Patterns en JavaScript
* Poluci√≥n del scope global
* Usar strings como argumentos a `setInterval` para invocar `eval()` internamente
* Modificar el prototipo de `Object` üí© NUNCA HAGAS ESTO
* Usar JS en un formulario inline
* Usar `document.write` en lugar de `document.createElement`

## Cagetorias de Design Pattern
* Creational: Patterns que se encargan de la creaci√≥n de objetos: (Constructor, Factory, Abstract, Prototype, Singleton, Builder)
* Structural: Patterns que se encargan de la composici√≥n de objetos: (Decorator, Facade, Flyweight, Adapter, Proxy)
* Behavioural: Patterns que se encargan de la comunicaci√≥n entre objetos y su comportamiento: (Iteratior, Mediator, Observer, Visitor)


# Design Patterns

A continuaci√≥n veremos una selecci√≥n de los Patterns mas importantes.

## Constructor
Un Constructor es un m√©todo usado para inicializar un objecto una vez que se ha creado un espacio en memoria para el objeto. Javascript no tiene clases de manera nativa, pero tiene funciones especiales que trabajan con objetos.

```javascript
var newObject = {};

var newObject = Object.create(Object.prototype);

var newObject = new Object();
```

El √∫ltimo ejemplo es un constructor, que se llama con el keyword `new`

Hay 4 maneras de definer las propiedades de un objeto en Javascript
```javascript
// 1. Usando el 'dot' syntax:
newObject.myKey = 'someValue';

// 2. Usando los []
newObject['myKey'] = 'someValue';

// 3. Usando el metodo Object.defineProperty (ES5+)
Object.defineProperty(newObject, 'myKey', {
  value: 'someValue',
  writable: true,
  enumerable: true,
  configurable: true
});

// 4. O en bloque usando Object.defineProperties (ES5+)
Object.defineProperties(newObject, {
  'myKey' : {
    value: 'someValue',
    writable: true
  },

  'anotherKey' : {
    value: 'someOtherValue',
    writable: false
  }
});
```

### Constructor B√°sico
Si llamamos a una funcion con la keyword `new`, le decimos a JS que queremos que la funci√≥n se comporte como un *constructor*. Dentro del constructor, la palabra clave `this` hace referencia al objecto que estamos creando.

```javascript
function Coche (modelo, a√±o, km) {

  this.modelo = modelo;
  this.a√±o = a√±o;
  this.km = km;

  this.toString = function () {
    return this.modelo + " tiene " + this.km + " km";
  };
}

// Uso:

// Podemos crear nuevas instancias de 'Coche'
var civic = new Coche("Honda Civic", 2009, 20000);
var mondeo = new Coche("Ford Mondeo", 2010, 5000);

civic.toString(); // -> "Honda Civic tiene 20000 km"
mondeo.toString(); // -> "Ford Mondeo tiene 5000 km"
```


### Constructor con Prototype
El anterior ejemplo redefine el m√©todo `toString` cada vez que creamos un objeto. Ser√≠a mejor compartir esta funcionalidad con todas las instancias de `Coche`

En javascript, las funciones, como la mayor√≠a de objetos, contienen un objeto llamado `prototype`. Cuando invocamos un constructor en JS para crear un Objeto, todas las propiedades del objeto estar√°n disponibles en el nuevo objeto.

```javascript
function Coche (modelo, a√±o, km) {
  this.modelo = modelo;
  this.a√±o = a√±o;
  this.km = km;
}

Coche.prototype.toString = function() {
  return this.modelo + ' tiene ' + this.km + ' km';
}
```

En este caso, todos las las instancias de Coche compartir√°n una referencia a *la misma* funci√≥n `toString`

## Module
Se definen como una manera de crear *encapsulaci√≥n* privada y p√∫blica, comparable a las clases en lenguajes convencionales.

Como JS no tiene clases de manera nativa, usamos m√≥dulos para emularlas.

# Usando Scope para emular Privacidad
Un M√≥dulo encapsula la idea de "privacidad", estado y organizaci√≥n mediante *closures*. De esta manera, solo exponemos una API P√∫blica, manteniendo el resto de m√©todos privados.

Sin embargo Javascript, a diferencia de otros lenguajes orientados a objetos, no tiene concepto de `private` o `public`, as√≠ que usamos scope para emularlo:

```javascript
var myNamespace = (function() {

  // esta variable es privada
  var myPrivateVar = 0;

  // este m√©todo tambi√©n
  var myPrivateMethod = function(foo) {
    console.log(foo);
  };

  return {

    // Una variable p√∫blica:
    myPublicVar: 'foo',

    // un m√©todo publico que usa cosas privadas
    myPublicFunction: function(bar) {

      // Incrementa el contador privado
      myPrivateVar++;

      // llama a nuestro m√©todo privado usando bar
      myPrivateMethod(bar);
    }
  };

})(); //<-- Invocamos la funci√≥n directamente
```

### Ventajas:
* Facilita la transici√≥n a JS para programadores de otros lenguajes Orientados a objetos que echan de menos las Classes.
* Provee soporte a datos privados

### Desventajas
* Los miembros privados y p√∫blicos se acceden de manera distinta, por tanto si queremos cambiar la visibilidad de un campo, necesitamos cambiar todas las referencias en las que √©ste se use.
* No podemos acceder a los miembros privados en m√©todos a√±adidos a nuestro m√≥dulo desp√©s de su creaci√≥n.
* No es posible escribir unit tests para miembros privados.
* Los miembros privados no pueden ser parcheados, as√≠ que si hay que reparar un bug, debemos modificar todos los miembros p√∫blicos.

[m√°s informaci√≥n sobre Module üá¨üáß](http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth)

## Singleton Pattern
Restringe la instanciaci√≥n de una clase a *un solo objeto*. Esto se implementa creando una clase con un m√©todo que crea una nueva instancia de la clase si la instancia no existe. Si la instancia ya ha sido creada, retornamos una referencia a ella.

Los singletons son √∫tiles cuando necesitamos retrasar la inicializaci√≥n de un objeto hasta que recibamos informaci√≥n requerida

```javascript
var mySingleton = (function () {
  // esta variable guarda una referencia al Singleton
  var instance;

  function init() {

    // Singleton
    // Metodos privados
    function privateMethod() {
      console.log("soy Privado");
    }

    var privateVariable = "yo tambi√©n soy privada";
    var privateRandom = Math.random();

    return  {
      // M√©todos p√∫blicos y variables
      publicMethod: function () {
        console.log( "el p√∫blico me puede ver!");
      },
      publicProperty: "y a mi tambi√©n",

      getRandomNumber: function() {
        return privateRandomNumber;
      }
    };
  };

  return {
    // aqui esta la clave =
    // Retornamos una referencia a la instancia del
    // singleton si ya existe. Si no, creamos un nuevo
    // singleton
    getInstance: function() {
      if (!instance) {
        instance = init();
      }
      return instance;
    }
  };

})();
```

Obtenemos acceso a los m√©todos del singleton llamando al m¬¥todo `MySingleton.getInstance()`. La diferencia entre una instancia est√°tica de una clase (un objeto) y un Singleton reside en que mientras un singleton puede ser implementado como una instancia est√°tica; tambien puede ser construido *lazily*, osea, s√≥lo en el momento en el que sea necesario.

Los Singletons son √∫tiles cuando necesitamos *exactamente un objeto* para coordinar otros objetos en un system.

De todas maneras, si necesitas un Singleton, puede ser que tengas que reevaluar tu dise√±o.


[M√°s informaci√≥n sobre Singletons üá¨üáß](http://www.ibm.com/developerworks/webservices/library/co-single/index.html)

## Observer Pattern
Un Observer es un patr√≥n en el que un objeto (llamado *Sujeto*) mantiene una lista de objetos que dependen de √©l (llamados *Observadores*), notific√°ndoles autom√°ticamente de cualquier cambio en el estado.

Si pasa algo interesante, el Sujeto puede notificar a todos los Observadores, emitiendo una notificaci√≥n que puede incluir datos relacionados con el tema de la notificaci√≥n.

Cuando un Observador ya no necesita (o desea) ser notificado de los cambios en el estado del Sujeto, √©ste √∫ltimo puede quitar al Observador de su lista de Observadores.

#### Gang of Four (GoF) definition:
> "One or more observers are interested in the state of a subject and register their interest with the subject by attaching themselves. When something changes in our subject that the observer may be interested in, a notify message is sent which calls the update method in each observer. When the observer is no longer interested in the subject's state, they can simply detach themselves."

### Implementando el Observer Pattern
Para implementar este patr√≥n, necesitamos los siguientes componentes:
* **Subject**: Mantiene una lista de Observadores, y los a√±ade o quita.
* **Observer**: Nuestro objeto tiene que implementar una interfaz para recibir notificaciones de cambio de estado en un Sujeto, por ejemplo, un *callback*
* **ConcreteSubject**: Emite notificaciones a los Observadores sobre los cambios de estado, y guarda el estado de los ConcreteObservers
* **ConcreteObserver**: Guardia una referencia al ConcreteSubject e implementa una interfaz de `update` que sea consistente con la del Sujeto

#### Observer List
```javascript
// lo primero que debemos construir es una lista de Observadores que nos permita a√±adir, quitar y buscar observadores:

function ObserverList() {
  this.observerList = [];
}

ObserverList.prototype.add = function(obj) {
  return this.observerList.push(obj);
}

ObserverList.prototype.count = function() {
  return this.observerList.length;
}

ObserverList.prototype.get = function(index) {
  if (index > -1 && index < this.observerList.length) {
    return this.observerList[index]:
  }
}

ObserverList.prototype.indexOf = function(obj, startIndex) {
  var i = startIndex;
  while (i < this.observerList.length) {
    if (this.observerList[i] === obj) {
      return i;
    }
    i++;
  }
  return -1;
};

ObserverList.prototype.removeAt = function(index) {
  this.observerList.splice(index, 1);
};
```

Nuestro `ObserverList` nos permite a√±adir, quitar y obtener nuestros `Observers`. Ahora lo haremos parte de nuestro `Subject`:
```javascript
function Subject() {
  this.observers = new ObserverList();
}

Subject.prototype.addObserver = function(observer) {
  this.observers.add(observer);
};

Subject.prototype.removeObserver = function(observer) {
  this.observers.removeAt(this.observers.indexOf(observer, 0));
};

Subject.prototype.notify = function(context) {
  var observerCount = this.observers.count();
  for (var i = 0; i < observercount; i++) {
    this.observers.get(i).update(context);
  }
};
```

El esqueleto de nuestros Observers funciona de esta manera:
```javascript
function Observer() {
  this.update = function() {
    // ...
  }
}
```

### Publish/Subscribe
Esta es la variante m√°s popular de el patron Observer en el mundo de Javascript.

El patr√≥n de Observer require que cualquier Observador que desee recibir notificaciones de un t√≥pico se tenga que subscribir al objeto que emita los eventos (Sujeto).

El patron Publish/Subscribe (PubSub) usa un canal de *topic/event* que se sit√∫a entre los objetos que desean recibir notificaciones (los *subscriptores*) y el objeto que emite los eventos (el *publicador*). Esto nos permite evitar dependencias entre los subscriptores y los publicadores.

Cualquier subscriptor se puede entonces registrar y recibir notificaciones emitidas por el publicador implementando un event handler apropiado:

```javascript
var noLeidos = 0;

// podemos tener un subscriptor atento a cuando lleguen nuevos mensajes
// y que se encargue de renderizarlos en la pantalla:
var subs1 = subscribe("inbox/mensajeNuevo", function(sujeto, datos) {
  // ** haz algo con el mensaje
  renderizaMensaje(datos);
});

// y otro subscriptor que se encargue de actualizar el contador de
// mensajes no leidos
var subs2 = subscribe("inbox/mensajeNuevo", function(sujeto, datos) {
  // actualiza el contador
  actualizarContador(++unreadCount);
});

// y luego en otra parte de nuestro c√≥digo:
publish("inbox/mensajeNuevo", [
  {
    sender: 'hello@google.com',
    body: 'hola! que tal?'
  }
]);
```

### Ventajas
* Es uno de los patrones m√°s importantes en Javascript
* Nos ayuda a pensar en las relaciones entre las diferentes partes de nuestro app
* Nos ayuda a identificar qu√© partes de nuestro sistema que contienen relaciones directas entre objetos pueden ser reemplazadas con sujetos + observadores
* Nos ayuda a dividir nuestro sistema en partes m√°s peque√±as, testables y no co-dependientes.

### Desventajas
* Es m√°s dificil garantizar que partes del sistema funcionen de manera correcta si las hacemos demasiado independientes.
* Los subscriptores no saben si los publicadores estan funcionando correctamente


## Prototype Pattern
Crea objetos basados en un patr√≥n de un objeto existente, clonandolo.

En prototypal inheritance evitamos las clases totalmente. En lugar de clases, simpelmente creamos copias de un objeto ya existente.

Prototypal Inheritance es una propiedad nativa de Javascript, asi que usar el Prototype pattern es f√°cil. Esto nos puede ayudar con el rendimiento de nuestras apps, ya que las funciones pueden ser creadas por referencia en lugar de crear copias individuales.

La manera est√°ndar de crear objetos a partir de un prototipo en ECMAScript 5 es usando `Object.create`:
```javascript
var miCoche = {
  nombre: "Ford Escort",

  conducir: function() {
    console.log("conduciendo!");
  },

  frenar: function() {
    console.log("stop!");
  },
}
// usa Object.create para instanciar un nuevo coche
var tuCoche = Object.create(miCoche);
```

Es posible hacer que objetos hereden de otros objetos, usando el segundo argumento de `Object.create`, el cual toma un objeto literal con las propiedades que queremos inicializar en el objeto:

```javascript
var vehiculo = {
  getModelo: function() {
    console.log("Modelo del veh√≠culo", this.modelo);
  }
};

var coche = Object.create(vehiculo, {
  id: {
    value: MY_GLOBAL.nextId(),
    // writable: false, configurable: false <-- false by default
    enumerable: true
  },

  modelo: {
    value: "Ford Escort",
    enumerable: true
  }
});
```

Esta es una manera un tanto compleja de establecer relaciones de prototipo. Una manera m√°s simple (y popular) es cambiar la propiedad `prototype` de una funci√≥n que retornamos desde otra funci√≥n:
```javascript
var vehiculoPrototipo = {
  init: function(modelo) {
    this.modelo = modelo;
  },

  getModelo: function() {
    console.log("Modelo del veh√≠culo: " + this.model);
  }
};

function vehiculo(modelo) {
  function F() {}
  F.prototype = vehiculoPrototipo;

  var f = new F();

  f.init(modelo);
  return f;
}

// lo usamos asi:
var coche = vehiculo("Ford Escort");
coche.getModelo();
```

En este caso `vehiculo` emula a un constructor, ya que el Prototype Pattern no include ninguna noci√≥n de inicializaci√≥n mas alla de unir un objeto a un prototipo.

## Command Pattern
El patr√≥n de Comando encapsula la invocaci√≥n de un m√©todo, request o operaci√≥n dentro de un s√≥lo objeto. Nos da la habilidad de parametrizar y pasar llamadas a m√©todos que puedan ser ejecutadas a nuestra discrecci√≥n.

Tambien nos permite desenlazar el objeto que invoca una accion del objeto que la implementa, lo que nos da un mayor grado de flexibilidad a la hora de cambiar clases concretas (e.j. objetos).

Nos aporta un medio de separar las responsabilidades de emitir comandos de la responsabilidad de ejecutarlos, permitiendonos delegar esta responsabilidad.

En nuestra implementaci√≥n, un comando simple une una acci√≥n con el objeto que la quiere invocar. Todos los objetos de comando con la misma interfaz pueden ser cambiados como se necesite. Esta es la principal ventaja de este pattern.

Como ejemplo vamos a imaginarnos que estamos haciendo un juego. En todos los juegos hay un trozo de c√≥digo que lee inputs del usuario (botones, eventos de teclado, clicks, etc). Toma cada input y lo traduce a una acci√≥n concreta en el juego:

![input-image](http://gameprogrammingpatterns.com/images/command-buttons-one.png) (from Game Programming Patterns)

Una implementaci√≥n simple de esto ser√≠a:

```javascript
handleInput() {
  if      (isPressed(BUTTON_X)) jump();
  else if (isPressed(BUTTON_Y)) fireGun();
  else if (isPressed(BUTTON_A)) swapWeapon();
  else if (isPressed(BUTTON_B)) crouch();
}
```

Esta funci√≥n se llama t√≠picamente una vez por frame en nuestro [game loop](http://gameprogrammingpatterns.com/game-loop.html). El problema con esto es que no podemos configurar el mapeado de los botones.

Para cambiar esto, podemos convertir nuestras llamadas directas a `jump()` y `fireGun()` en cosas que podamos cambiar (i.e. asignar, como una variable).

Para ello, definimos una interfaz `Command`:
```javascript
var Command = function() {
  this.execute = function() {};
}
```

Por ejemplo, podemos crear comandos para cada una de las acciones de nuestro juego, que implementen la misma interfaz (i.e. que tengan la propiedad 'execute')
```javascript
function JumpCommand() {
  this.execute = function() {
    jump();
  }
}

function FireCommand() {
  this.execute = function() {
    fireGun();
  }
}
```

Entonces, podemos modificar nuestro `inputHandler` para tener, para cada bot√≥n, un pointer a un comando:
```javascript
function InputHandler () {

  var botones = {
    X : new Command(),
    Y : new Command(),
    A : new Command(),
    B : new Command()
  };

  return {
    handleInput() {
      if      (isPressed(BUTTON_X)) botones.X.execute();
      else if (isPressed(BUTTON_Y)) botones.Y.execute();
      else if (isPressed(BUTTON_A)) botones.A.execute();
      else if (isPressed(BUTTON_B)) botones.B.execute();
    },

    setButton(boton, comando) {
      // nos aseguramos de que `comando` implementa la interfaz
      // de Command
      if (!comando.hasOwnProperty('execute')) return null
      botones[boton] = comando;
    }
  }
}
```

Como podeis ver, hemos desencajado los botones de las funciones del juego, lo que nos da una capa de abstraccion.

El patr√≥n de Command es b√°sico si queremos implementar la opci√≥n de deshacer `undo`. Para eso extendemos la interfaz de command para tener una funci√≥n `undo` que desahaga la acci√≥n del comando.
```javascript
function Command () {

  this.execute = function() {};
  this.undo = function() {};

}
```

Por ejemplo si estas implementando un editor, podriamos manterer una lista de comandos, y si quieres deshacer, pues simplemente ejecutas la funci√≥n de deshacer del ultimo comando:
```javascript
function CommandHistory() {
  this.undoHistory = [];
  this.redoHistory = [];

  this.performCommand = function(command) {
    undoHistory.push(command);
    command.execute();
  }

  this.undo = function() {
    var lastCommand = undoHistory.pop();
    if (!lastCommand) return null;
    lastCommand.undo();
    redoHistory.push(lastCommand);
  }

  this.redo = function() {
    var lastCommand = redoHistory.pop();
    if (!lastCommand) return null;
    lastCommand.execute();
    undoHistory.push(lastCommand);
  }

}
```
